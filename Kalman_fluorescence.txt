// In order to change the model you have to change the:
// 1.define the observation model function
// 2.multiplyligand
// 3.define_rate_matrix
// 4.model assumption

// M_states Python
// number ligand multiply  python script
// N_free_param checken in python script
// check weather you python script has the right ligand conc multiplcation

functions{

vector flattenParameterProposal(real i_single_channel,
                    real[] rates,
                    real[] ratio,
                    real[] N_ion_trace,
                    real var_exp,       //measurement noise
                    real OpenVar,      //open channel noise
                    real var_fluoresc,  //measurement noise
                    real lambda_fluoresc, int N_free_para, int N_conc){
     vector[N_free_para+ N_conc/2 + 5] flattendParameters;
     int current = 1;
     for(i in 1 : N_free_para/2)
     {
      flattendParameters[current]  = rates[i];
      current+=1;
     }

     for(i in 1 : N_free_para/2)
     {
      flattendParameters[current]  = ratio[i];
      current+=1;
     }

     for(i in 1 : N_conc/2)
     {
      flattendParameters[current]  = N_ion_trace[i] * i_single_channel;
      current+=1;
     }

     flattendParameters[current]  = i_single_channel;
     current+=1;

     flattendParameters[current]  = var_exp;
     current+=1;

     flattendParameters[current]  = OpenVar;
     current+=1;


     flattendParameters[current]  = var_fluoresc;
     current+=1;

     flattendParameters[current]  = lambda_fluoresc;
     current+=1;
     return flattendParameters;
}

matrix to_symmetric_matrix(matrix x) {
  return 0.5 * (x + x ');
}


real[] flattenData(vector[] y_time_trace,vector y_equi,real dif_time,real off_set, vector ligand_base,
vector ligand_offset_jump, vector ligant_current, real  numeric_precision,  int N_data, int N_free_para,
 int resultSize, real time_offset_off_ligand_wash)
{
   real result[resultSize] ;
   int current;
   for (n_data in 1: N_data)
   {
     result[n_data*2-1] = y_time_trace[n_data,1];
     result[n_data*2] = y_time_trace[n_data,2];
   }
   current = 2*N_data+1;
   result[current] = y_equi[1];
   current+=1;

   result[current] = y_equi[2];
   current+=1;

   result[current] = dif_time;
   current+=1;
   //print("dif_time", dif_time);

   result[current] = off_set;
   current+=1;
   //print("off_set_time", off_set);

    for (i in 1 : N_free_para)
    {
      result[current] = ligand_base[i];
        current+=1;
    }

    for (i in 1 : N_free_para)
    {
      result[current] = ligand_offset_jump[i];
        current+=1;
    }

    for (i in 1 : N_free_para)
    {
      result[current] = ligant_current[i];
        current+=1;
    }

   result[current] = numeric_precision;
   current+=1;

   result[current] = time_offset_off_ligand_wash;
   current +=1;

   return result;
}

vector return_vector(int legth, real value)
    {
        vector[legth] zero;
        for(i in 1:legth)
        {
            zero[i] = value;
        }
        return zero;
    }

vector  calc_first_distribut(int M_states, vector Start_values, matrix rate_mat,real time_off_set, real LATENT_TIME)
        {
        vector[M_states] result;
        result = matrix_exp(rate_mat * (time_off_set + 0.0002 * LATENT_TIME)) * Start_values;
        return result;
        }

vector  propagate_mu_in_time(int M_states, vector mu_old, matrix transition_mat)
        {
        vector[M_states] result;
        result = transition_mat * mu_old;
        return result;
        }

vector update_mu_due_measurement(int M_states, matrix kalmann_gain, vector mu,
                                 vector y_data, vector observation_mean, real N_trace)
{
    vector[M_states] result;
    //y_data - obersavtional_mean is the innovation basically the noise from the measurement
    result = mu + (kalmann_gain * (y_data - observation_mean))/N_trace;
    return result;
}

/*matrix to_symmetric_matrix(matrix x){
  matrix[2,2] result;
  result = x-x';
  if(fabs(result[2,1]) > 0.00001){
    reject("precision matrix is strongly antisymmetric");
  }
  return 0.5 * (x + x ');
}*/



matrix update_covarianve_due_measurement(int M_states,matrix measurement_precison,
                                         matrix corre_mat,matrix kalmann_gain)
{
    matrix[M_states,M_states] result;
    result = corre_mat - kalmann_gain * measurement_precison * kalmann_gain';
    //corremat_enthält bereits N_trace

    for(i in 1 : M_states){
        for(j in 1 : M_states){
            if (fabs(corre_mat[i,j]-corre_mat[i,j])  > 0.000001){
                reject("correlation_matrix[i,j] != correlation_matrix[j,i]", i,j, fabs(corre_mat[i,j]-corre_mat[i,j]));
            }
        }
    }
    return result;
}

matrix propagate_covariance_in_time(int M_states, matrix corre_mat_old,
                                    vector mu_new, matrix transition, vector mu_old, real N_trace){
    matrix[M_states,M_states] result;
    vector[M_states] population_mean;
    //population_mean = mu_old * N_trace;
    //Standart corre_mat_old enthält bereits N_trace
    result = N_trace*(diag_matrix(mu_new) - transition * diag_matrix(mu_old)* transition')
    //result = N_trace*(diag_matrix(mu_new) - mu_new * mu_new')
                                 + transition *  corre_mat_old * transition';

    //myrule
    //result = transition *  corre_mat_old * transition';
    //for(i in 1 : M_states){
    //    result += population_mean[i]*(diag_matrix(transition[:,i])- transition[:,i] * transition[:,i]');
    //}

    //old Try result = N_trace*(diag_matrix(mu_new) - mu_new * mu_new')
    //                             + transition *  corre_mat_old * transition';

    return result;
}

vector calc_measurement_mean(real N_ion_trace, matrix observ_model,
                            vector mu)
{
       vector[2] result;
       result = N_ion_trace * observ_model * mu;
       return result;
}

matrix precision_clamp_flurescences(matrix observ_model, matrix corre_mat, matrix ObservNoise_covariance)
{
       matrix[2,2] result;

       result = ObservNoise_covariance + (observ_model * corre_mat) * observ_model';

       if(fabs(determinant(result)) < 0.0000001){

        reject("Determinat is zero no matrix inversion possible");
       }
       if(fabs(result[2,1]-result[1,2]) > 0.00001){
            reject("precision matrix is strongly antisymmetric", result);
       }
       return result;
}
matrix calc_kalmann_gain(real N_ion_trace, int M_states,
                        matrix observation_model, matrix corre_mat,
                        matrix measurement_precision){

    matrix[M_states,2] result;
    result = corre_mat * observation_model' * measurement_precision;
    return result;
}

matrix update_correlation_matrix(int M_states, real N_ion_trace, matrix precision,
                                matrix corre_mat, matrix transition_mat, vector mu, vector mu_old,
                                 matrix kalmannGain){
       matrix[M_states, M_states] result;
       result = update_covarianve_due_measurement(M_states, precision,
                                                  corre_mat, kalmannGain);
       result = propagate_covariance_in_time(M_states, result, mu, transition_mat,
                                                 mu_old, N_ion_trace);
       return result;
}

matrix  define_observation_model_CCOCO(int M_states,
                                real i_single_channel,
                                real lambda_fluoresc){
        matrix[2,M_states] obs;
        row_vector[M_states] fluo = lambda_fluoresc  * i_single_channel * to_row_vector([0, 0.5, 1, 1, 0.5]);
        obs = [fluo,
               [0,0,0, i_single_channel,i_single_channel]];
        return obs;
        }

matrix  define_observation_model_CCO_CO(int M_states,
                                real i_single_channel,
                                real lambda_fluoresc){
        matrix[2,M_states] obs;
        row_vector[M_states] fluo = lambda_fluoresc  * i_single_channel * to_row_vector([0, 0.5, 1, 1, 0.5]);
        obs = [fluo,
               [0,0,0, i_single_channel,i_single_channel]];
        return obs;
        }


matrix  define_observation_model_CCCO(int M_states,
                                real i_single_channel,
                                real lambda_fluoresc){
        matrix[2,M_states] obs;
        row_vector[M_states] fluo = lambda_fluoresc  * i_single_channel * to_row_vector([0,0.5,1,1]);
        obs = [fluo,
               [0,0,0, i_single_channel]];
        return obs;
        }

matrix  define_observation_model_CCOC(int M_states,
                                real i_single_channel,
                                real lambda_fluoresc){
        matrix[2,M_states] obs;
        row_vector[M_states] fluo = lambda_fluoresc  * i_single_channel * to_row_vector([0,0.5,1,0.5]);
        obs = [fluo,
               [0,0,0, i_single_channel]];
        return obs;
        }

matrix  define_observation_model_CCO(int M_states,
                                real i_single_channel,
                                real lambda_fluoresc){
        matrix[2,M_states] obs;
        row_vector[M_states] fluo = lambda_fluoresc  * i_single_channel * to_row_vector([0,1,1]);
        obs = [fluo,
              [0,0, i_single_channel]];
        return obs;
        }

matrix assign_param_to_rate_matrix_CCO(vector theta,
                                   int M_states)
    {
        matrix[M_states, M_states] rates_mat;
        rates_mat    = [[      0 , theta[1],        0],
                        [theta[2],        0, theta[3]],
                        [       0, theta[4],        0]];

        return rates_mat;
    }



matrix assign_param_to_rate_matrix_CCCO(vector theta,
                                   int M_states)
    {
        matrix[M_states, M_states] rates_mat;
        rates_mat    = [[      0 , theta[1],        0,         0],
                        [theta[2],        0, theta[3],         0],
                        [       0, theta[4],        0,  theta[5]],
                        [       0,        0,  theta[6],        0]];



        return rates_mat;
    }

matrix assign_param_to_rate_matrix_CCOC(vector theta,
                                   int M_states)
    {
        matrix[M_states, M_states] rates_mat;
        rates_mat    = [[      0 , theta[1],        0,         0],
                        [theta[2],        0, theta[3],   theta[5]],
                        [       0, theta[4],        0,          0],
                        [       0, theta[6],        0,         0]];



        return rates_mat;
    }

matrix assign_param_to_rate_matrix_CCOCO(vector theta,
                                   int M_states)
    {
        matrix[M_states, M_states] rates_mat;
        rates_mat    = [[      0 , theta[1],        0,         0,             0],
                        [theta[2],        0, theta[3],         0,      theta[7]],
                        [       0, theta[4],        0,  theta[5],             0],
                        [       0,        0,  theta[6],        0,             0],
                        [       0, theta[8],        0,         0,             0]];



        return rates_mat;
    }
matrix assign_param_to_rate_matrix_CCO_CO(vector theta,
                                   int M_states)
    {
        matrix[M_states, M_states] rates_mat;
        rates_mat    = [[      0 , theta[1],        0,         0,             0],
                        [theta[2],        0, theta[3],         0,      theta[7]],
                        [       0, theta[4],        0,  theta[5],             0],
                        [       0,        0,  theta[6],        0,      theta[9]],
                        [       0, theta[8],        0, theta[10],             0]];



        return rates_mat;
    }


    vector multiply_ligandconc_CCO(real[] theta_array,
                           real[] equili,
                           int N_free_para,
                           vector ligand_conc)
    {

        vector[N_free_para] theta;
        theta[1] = theta_array[1];
        theta[2] = theta_array[1]*24.0*equili[1];
        theta[3] = theta_array[2];
        theta[4] = theta_array[2] * 10 * equili[2];

        return theta .* ligand_conc;
    }



    vector multiply_ligandconc_CCCO(real[] theta_array,
                           real[] equili,
                           int N_free_para,
                           vector ligand_conc)
    {

        vector[N_free_para] theta;
        //print("ratio: ", theta_array[6]);
        theta[1] = theta_array[1]/5;
        theta[2] = theta_array[1]/5*24.0*equili[1];
        theta[3] = theta_array[2];
        theta[4] = theta_array[2]* 6.0/5.0 * equili[2]; //3/5 * 2

        theta[5] = theta_array[3]/50;
        theta[6] = theta_array[3]/50* 10 * equili[3];  //8/2*2

        return theta .* ligand_conc;
    }

    vector multiply_ligandconc_CCOC(real[] theta_array,
                           real[] equili,
                           int N_free_para,
                           vector ligand_conc)
    {

        vector[N_free_para] theta;
        //print("ratio: ", theta_array[6]);
        theta[1] = theta_array[1];
        theta[2] = theta_array[1]*10*24.0*equili[1];
        theta[3] = theta_array[2];
        theta[4] = theta_array[2]*10* 6.0/5.0 * equili[2]; //3/5 * 2

        theta[5] = theta_array[3];
        theta[6] = theta_array[3]*10 * 10 * equili[3];  //8/2*2

        return theta .* ligand_conc;
    }


vector multiply_ligandconc_CCOCO(real[] theta_array,
                           real[] equili,
                           int N_free_para,
                           vector ligand_conc)
    {

        vector[N_free_para] theta;
        theta[1] = theta_array[1];
        theta[2] = theta_array[1]*24.0*equili[1];
        theta[3] = theta_array[2];
        theta[4] = theta_array[2]* 6.0/5.0 * equili[2]; //3/5 * 2

        theta[5] = theta_array[3];
        theta[6] = theta_array[3] * 100 * equili[3];  //8/2*2

        theta[7] = 5*theta_array[4];
        theta[8] = 0.001* equili[4]* theta_array[4];  //8/2*2

        return theta .* ligand_conc;
    }


vector multiply_ligandconc_CCO_CO(real[] theta_array,
                           real[] equili,
                           int N_free_para,
                           vector ligand_conc)
    {

        vector[N_free_para] theta;
        //print("ratio: ", theta_array[6]);
        theta[1] = 0.6*theta_array[1];
        theta[2] = 0.6*theta_array[1]*24.0*equili[1];
        theta[3] = theta_array[2];

        theta[4] = theta_array[2]* 6.0/5.0 * equili[2]; //3/5 * 2


        theta[5] = 0.03*theta_array[3];
        theta[6] = 0.03*theta_array[3] * 100 * equili[3];  //8/2*2

        theta[7] = theta_array[4];
        theta[8] = 0.1*equili[4]; //theta_array[4] * 0.2 * equili[4];  //8/2*2

        theta[9] = theta_array[5];

        //theta[10] = exp(log(theta[3])+log(theta[5])+log(theta[8])+log(theta[9])-log(theta[4])-log(theta[6])-log(theta[7]));
        theta[10] = 1* equili[5];  //8/2*2

        return theta .* ligand_conc;
    }





matrix assign_param_to_rate_matrix(vector theta,
                                   int M_states)
    {
        matrix[M_states, M_states] rates_mat;
        rates_mat    = [[      0 , theta[1],        0,         0,        0],
                        [theta[2],        0, theta[3],         0,        0],
                        [       0, theta[4],        0,  theta[5],        0],
                        [       0,        0,  theta[6],        0,  theta[7]],
                        [       0,        0,        0,  theta[8],        0]];


        return rates_mat;
    }

    vector multiply_ligandconc(real[] theta_array,
                           real[] equili,
                           int N_free_para,
                           vector ligand_conc)
    {

        vector[N_free_para] theta;
        //print("ratio: ", theta_array[6]);
        theta[1] = theta_array[1];
        theta[2] = theta_array[1]*24.0*equili[1];
        theta[3] = theta_array[2];
        theta[4] = theta_array[2]* 6.0/5.0 * equili[2]; //3/5 * 2

        theta[5] = theta_array[3];
        theta[6] = theta_array[3] * 2.0/8.0 * equili[3];  //8/2*2

        theta[7] = theta_array[4];
        theta[8] = theta_array[4]* 10* equili[4];
        return theta .* ligand_conc;
    }

matrix assign_diagonal_elements(matrix rates,
                                    int M_states,
                                    real numeric_precision)
    {
        vector[M_states] diag;
        matrix[M_states,M_states] result;
        for(id in 1: M_states)
        {

            diag[id] = -1 * sum(col(rates, id));
        }
        result = diag_matrix(diag) + rates;
        for(id in 1 : M_states){
            if( fabs(sum(col(result, id))) > numeric_precision){
                print("column", id);
                print("sum column rate_mat", sum(col(result, id)));
                print("Warning assigmend goes wrong!! Ill defined rate matrix");
                print("full rate Matrix", result);
                reject("This metropils states is rejected")
            }
        }

        return result;
    }

matrix create_rate_matrix(real[] theta_array,
                           real[] ratios,
                           int N_free_para,
                           vector ligand_conc,
                        int M_states,
                        real numeric_precision){

        matrix[M_states,M_states] rates;
        vector[N_free_para] theta_vec = multiply_ligandconc_CCCO(theta_array,
                           ratios,
                           N_free_para,
                           ligand_conc);

        rates = assign_param_to_rate_matrix_CCCO(theta_vec, M_states);
        rates  = assign_diagonal_elements(rates,M_states,
                                    numeric_precision);

        return rates;
    }


vector calculate_equilibrium_solution(int M_states,
                                       real numeric_precision,
                                       real[] theta_array,
                           real[] equili,
                           int N_free_para,
                           vector ligand_conc)
    {

        matrix[M_states, M_states] equilibrium;
        vector[M_states] zero_one;
        vector[M_states] result;
        row_vector[M_states] ones;
        matrix[M_states, M_states] rates = create_rate_matrix(theta_array,
                           equili,
                           N_free_para,
                           ligand_conc,
                           M_states,
                           numeric_precision);




        for(id in 1 : M_states){
            ones[id] = 1;
        }

        equilibrium = rates;

        equilibrium[M_states] = ones;

        if(determinant(equilibrium) == 0){
            vector[M_states] dummy = return_vector(M_states,0);
            reject("determiant(equilibrium) = ", determinant(equilibrium));
            return dummy;
        }

        zero_one = return_vector(M_states,0);
        zero_one[M_states] = 1;


        result = inverse(equilibrium) * zero_one;

        if(fabs(sum(result)-1)> numeric_precision){
                print("WARNING!");
                print("Equilibrium solution is ill defined");
                reject("sum(result)-1 should be = 0 but found: ",fabs(sum(result)-1));
        }

        return result;
    }
matrix calculate_starting_correlation(int M_states, vector Starting_values, real N_trace)
{
        matrix[M_states,M_states] starting_correlation;
        // next line tensor product
        starting_correlation = N_trace * (diag_matrix(Starting_values) - Starting_values * Starting_values');
        return starting_correlation;
    }

real[,,] calculate_likelihood_for_each_trace(int N_free_para,
                                            real i_single_channel,
                                             int N_data,
                                            int M_states,
                             real N_ion, real[] rates,
                            real[] ratio,  real numeric_precision,
                            vector ligand_conc_before_step,
                            vector ligantOffsetJump,
                            vector ligand_conc_after_step,
                            real var_exp, real var_open, vector[]  y_start, real dif_time,
                            vector y_equi,
                            real time_offset,
                            real var_fluoresc,
                            real lambda_fluoresc,
                            real time_offset_off_ligand_wash,
                            int TRUE_FALSE)
    {
    matrix[M_states,M_states] rate_matrix;
    matrix[M_states,M_states] transition_mat;
    matrix[2,2]               precision;

    //mean anc covaraicane for each time step 2 dimensional data makes 2 cross 3 matrix
    real                    calculation_container[2,3, N_data+1];

    vector[M_states]             mu_old;
    //Kalmangain acts onto measurement vector such that it needs to share
    //its columns with the rows of the observation

    matrix[M_states, 2]   kalmann_gain;
    //   Assuming that we create the diff immagine with a reference signal that is at least a factor 10
    //     bigger then each ligand concentration...
    real var_backround_noise = pow(ligand_conc_after_step[2]*var_fluoresc,2)/(4000 / (10 * 0.25) * 64)+ ligand_conc_after_step[2]*var_fluoresc;


    matrix[2,2]          observ_covariance       = [[var_backround_noise,    0],
                                                    [0,        var_exp]];



    ///new for Poisson counting noise
    matrix[2,2]         TimeDependet_obersCov;
    vector[M_states] mu ;
    matrix[M_states,M_states] corre_mat;




    matrix[2,M_states] observation_model = define_observation_model_CCCO(M_states, i_single_channel, lambda_fluoresc);

    /////////////////////////////////////////////////////////////////////////////////////////////////////

    mu = calculate_equilibrium_solution(M_states, numeric_precision,
                                        rates, ratio, N_free_para,
                                        ligand_conc_before_step);
    corre_mat =  calculate_starting_correlation(M_states, mu, N_ion);

    if(TRUE_FALSE == 1){
        //Jump ligand washout part of the timetrace
        observ_covariance = [[0,    0],
                            [0,        var_exp]];

        rate_matrix = create_rate_matrix(rates, ratio, N_free_para,
                        ligantOffsetJump, M_states, numeric_precision);

        transition_mat = matrix_exp(rate_matrix * time_offset_off_ligand_wash);

        mu_old = mu;
        mu = propagate_mu_in_time(M_states, mu_old, transition_mat);
        corre_mat = propagate_covariance_in_time(M_states, corre_mat, mu, transition_mat,
                                                 mu_old, N_ion);
    }




    calculation_container[:,1,1] = to_array_1d(calc_measurement_mean(N_ion, observation_model, mu));

    ///new for Poisson counting noise
    TimeDependet_obersCov =[[calculation_container[1,1,1],                             0],
                            [0,                   var_open/i_single_channel* calculation_container[2,1,1]]];

    precision = precision_clamp_flurescences(observation_model, corre_mat, observ_covariance + TimeDependet_obersCov);

    calculation_container[:,2:3,1] = to_array_2d(precision);

    rate_matrix = create_rate_matrix(rates, ratio, N_free_para,
                        ligand_conc_after_step, M_states, numeric_precision);

    transition_mat = matrix_exp(rate_matrix * time_offset);

            for(i in 1 : M_states){
                if(fabs(sum(transition_mat[:,i])-1) > numeric_precision){
                    print("sum Transition mat column",fabs(sum(transition_mat[:,i])-1));
           }}

    kalmann_gain = calc_kalmann_gain(N_ion, M_states, observation_model, corre_mat,
                                    inverse(precision));

    mu = update_mu_due_measurement(M_states, kalmann_gain, mu, y_equi,
                                  to_vector(calculation_container[:,1,1]), N_ion);

    mu_old = mu;

    mu = propagate_mu_in_time(M_states, mu_old, transition_mat);




    corre_mat = update_correlation_matrix(M_states, N_ion,precision,
                                          corre_mat, transition_mat, mu, mu_old, kalmann_gain);

    transition_mat = matrix_exp(rate_matrix * dif_time);

    for(n_data in 1: N_data){
        if(fabs(sum(mu)-1) > numeric_precision){
                print("n_data: ", n_data);
                print("sum mu: ",fabs(sum(mu)-1));
        }


       calculation_container[:,1,n_data+1] = to_array_1d(calc_measurement_mean(N_ion,
                                                              observation_model, mu));


       //newww for poissin
       TimeDependet_obersCov =[[calculation_container[1,1,n_data+1],                          0],
                               [0,              var_open/i_single_channel * calculation_container[2,1,n_data+1]]];

       precision = precision_clamp_flurescences(observation_model, corre_mat, observ_covariance+ TimeDependet_obersCov);

       calculation_container[:,2:3,n_data+1] = to_array_2d(precision);

       kalmann_gain = calc_kalmann_gain(N_ion, M_states, observation_model,
                                       corre_mat,  inverse(precision));

       mu = update_mu_due_measurement(M_states, kalmann_gain, mu,
                                            y_start[n_data],
                                            to_vector(calculation_container[:,1,n_data+1]), N_ion);

       mu_old = mu;
       mu = propagate_mu_in_time(M_states, mu_old, transition_mat);
       ///new for Poisson counting noise

       corre_mat = update_correlation_matrix(M_states, N_ion, precision, corre_mat,
                                               transition_mat, mu, mu_old, kalmann_gain);
      }




    return calculation_container;
}


vector wrapped_calculate_likelyhood(vector params, vector ingnoreMe, real[] x_r, int[] x_i)
{
       // unbox integer data
       int N_free_para = x_i[1];
       int N_data = x_i[2];
       int M_states = x_i[3];
       int id =  x_i[4];
       int N_conc = x_i[5];
       int CPU_id = x_i[6];
       int current;
       vector[2] y_start[N_data];
       vector[2] y_equi;
       real dif_time;
       real off_set;
       vector[N_free_para] ligant_start;
       vector[N_free_para] ligantOffsetJumb;
       vector[N_free_para] ligant_current;
       real numeric_precision;
       real i_single_channel;
       real rates[N_free_para/2];
       real ratio[N_free_para/2];
       real N_ion_trace[N_conc];
       real var_exp;
       real OpenVar;
       real var_fluoresc;
       real lambda_fluoresc;
       real time_offset_off_ligand_wash;
       real result[2,3,N_data+1];
       real SumLogLike[N_data+1];
       real LogLikeTrace;
       vector[2*3*(N_data+1)+1] flattend_result;

       // unbox real data
       current = 1;

       for (n_data in 1: N_data)
       {
         y_start[n_data,1] = x_r[current];
         current += 1;
         y_start[n_data,2] = x_r[current];
         current += 1;
       }


       y_equi[1] = x_r[current];
       current += 1;
       y_equi[2] = x_r[current];
       current += 1;

       dif_time = x_r[current];
       current += 1;

       off_set = x_r[current];
       current += 1;

       ligant_start  = to_vector(x_r[current:current+N_free_para-1]);
       current += N_free_para;

       ligantOffsetJumb  = to_vector(x_r[current:current+N_free_para-1]);
       current += N_free_para;

       ligant_current  = to_vector(x_r[current:current+N_free_para-1]);
       current += N_free_para;

       numeric_precision  = x_r[current];
       current += 1;

       time_offset_off_ligand_wash = x_r[current];
       current +=1;

       // unbox parameters
       current = 1;
       for(i in 1 : N_free_para/2)
       {
        rates[i] = params[current];
        current+=1;
       }

       for(i in 1 : N_free_para/2)
       {
        ratio[i] = params[current];
        current+=1;
       }
       for(i in 1 : N_conc/2)
       {
        N_ion_trace[i] = params[current];
        current+=1;
        //print(N_ion_trace[i]);
       }
       i_single_channel  = params[current];
       current+=1;
       var_exp  = params[current];
       current+=1;
       OpenVar  = params[current];
       current+=1;
       var_fluoresc  = params[current];
       current+=1;
       lambda_fluoresc  = params[current];
       current+=1;


       {int n_id = id;
       int True_or_False = 0;
       if(id > N_conc/2){
            n_id = N_conc+1 - n_id;
       }
       if( CPU_id > N_conc){
            True_or_False = 1;
       }


       result = calculate_likelihood_for_each_trace(N_free_para,
                                                    i_single_channel, N_data, M_states,
                                                    N_ion_trace[n_id],rates,
                                                    ratio, numeric_precision,
                                                    ligant_start, ligantOffsetJumb,
                                                    ligant_current, var_exp, OpenVar,
                                                    y_start, dif_time, y_equi,
                                                    off_set, var_fluoresc,
                                                    lambda_fluoresc, time_offset_off_ligand_wash,
                                                    True_or_False);
       }
       //calc loglikelihood
        SumLogLike[1] = multi_normal_lpdf(y_equi|to_vector(result[:,1,1]),
                                                      to_matrix(result[:,2:3,1]));
        {
        for(n_data in 1: N_data)
             {

             vector[2] mean_signal;
             matrix[2,2] output_covari;
             mean_signal = to_vector(result[:,1, n_data+1]);
             output_covari = to_matrix(result[:,2:3,n_data+1]);
             SumLogLike[n_data+1] = multi_normal_lpdf(y_start[n_data]|mean_signal, output_covari);

             }

        LogLikeTrace = sum(SumLogLike);
        }


      current = 1;
      for (i in 1: 2)
      {
        for (j in 1: 3)
        {
          for (k in 1: N_data+1)
          {
            flattend_result[current] = result[i,j,k];
            current +=1;
          }
        }
      }

      flattend_result[current] = LogLikeTrace;
      return flattend_result;
}



vector wrapped_calculate_likelyhood_less_memo(vector params, vector ingnoreMe, real[] x_r, int[] x_i)
{
       // unbox integer data
       int N_free_para = x_i[1];
       int N_data = x_i[2];
       int M_states = x_i[3];
       int id =  x_i[4];
       int N_conc = x_i[5];
       int CPU_id = x_i[6];
       int current;
       vector[2] y_start[N_data];
       vector[2] y_equi;
       real dif_time;
       real off_set;
       vector[N_free_para] ligant_start;
       vector[N_free_para] ligantOffsetJumb;
       vector[N_free_para] ligant_current;
       real numeric_precision;
       real i_single_channel;
       real rates[N_free_para/2];
       real ratio[N_free_para/2];
       real N_ion_trace[N_conc];
       real var_exp;
       real OpenVar;
       real var_fluoresc;
       real lambda_fluoresc;
       real time_offset_off_ligand_wash;
       real result[2,3,N_data+1];
       real SumLogLike[N_data+1];
       vector[1] LogLikeTrace;
       //vector[2*3*(N_data+1)+1] flattend_result;

       // unbox real data
       current = 1;

       for (n_data in 1: N_data)
       {
         y_start[n_data,1] = x_r[current];
         current += 1;
         y_start[n_data,2] = x_r[current];
         current += 1;
       }


       y_equi[1] = x_r[current];
       current += 1;
       y_equi[2] = x_r[current];
       current += 1;

       dif_time = x_r[current];
       current += 1;

       off_set = x_r[current];
       current += 1;

       ligant_start  = to_vector(x_r[current:current+N_free_para-1]);
       current += N_free_para;

       ligantOffsetJumb  = to_vector(x_r[current:current+N_free_para-1]);
       current += N_free_para;

       ligant_current  = to_vector(x_r[current:current+N_free_para-1]);
       current += N_free_para;

       numeric_precision  = x_r[current];
       current += 1;

       time_offset_off_ligand_wash = x_r[current];
       current +=1;

       // unbox parameters
       current = 1;
       for(i in 1 : N_free_para/2)
       {
        rates[i] = params[current];
        current+=1;
       }

       for(i in 1 : N_free_para/2)
       {
        ratio[i] = params[current];
        current+=1;
       }
       for(i in 1 : N_conc/2)
       {
        N_ion_trace[i] = params[current];
        current+=1;
        //print(N_ion_trace[i]);
       }
       i_single_channel  = params[current];
       current+=1;
       var_exp  = params[current];
       current+=1;
       OpenVar  = params[current];
       current+=1;
       var_fluoresc  = params[current];
       current+=1;
       lambda_fluoresc  = params[current];
       current+=1;


       {int n_id = id;
       int True_or_False = 0;
       if(id > N_conc/2){
            n_id = N_conc+1 - n_id;
       }
       if( CPU_id > N_conc){
            True_or_False = 1;
       }


       result = calculate_likelihood_for_each_trace(N_free_para,
                                                    i_single_channel, N_data, M_states,
                                                    N_ion_trace[n_id],rates,
                                                    ratio, numeric_precision,
                                                    ligant_start, ligantOffsetJumb,
                                                    ligant_current, var_exp, OpenVar,
                                                    y_start, dif_time, y_equi,
                                                    off_set, var_fluoresc,
                                                    lambda_fluoresc, time_offset_off_ligand_wash,
                                                    True_or_False);
       }
       //calc loglikelihood
        SumLogLike[1] = multi_normal_lpdf(y_equi|to_vector(result[:,1,1]),
                                                      to_matrix(result[:,2:3,1]));
        {
        //vector[N_data] test;
        for(n_data in 1: N_data)
             {

             vector[2] mean_signal;
             matrix[2,2] output_covari;
             mean_signal = to_vector(result[:,1, n_data+1]);
             output_covari = to_matrix(result[:,2:3,n_data+1]);
             SumLogLike[n_data+1] = multi_normal_lpdf(y_start[n_data]|mean_signal, output_covari);
             }
        LogLikeTrace[1] = sum(SumLogLike);
        }

      return LogLikeTrace;
}
}
data {
    /*Structure of the Data...............................*/
    int<lower = 1, upper = 10>          N_conc;                        // how many concetrations
    int<lower = 5, upper = 1000>        N_data[2];                     // how many data elements per concentratrion
    int<lower = 10, upper = 4000000>    N_ion_ch;                // how many channels

    /*The patch..........................................*/
    real<lower = 0, upper = 101>                                    var_fluores_hat;

    /*The Data...........................................*/
    vector<lower = -1200, upper = 100*N_ion_ch+4000>[2]              y_start[N_conc, N_data[1]];
    vector<lower = -1200,
     upper = N_ion_ch+4000>[2]                                  y_equi_before_jump[N_conc];
    real<lower = 0.00001, upper = 0.2>                          dif_time[N_conc];
    vector<lower = -1200, upper = 100*N_ion_ch+4000>[2]                y_dec[N_conc,N_data[2]];
    vector<lower = -1000, upper = 100*N_ion_ch+2000>[2]                 y_equi_after_jump[N_conc];
    real<lower = 0.00001, upper = 0.4>                  dif_time_dec[N_conc];
    real<lower = 0.0, upper = 0.005>                    time_off_set_dec[N_conc];
    real<lower = 0.0000, upper = 1>                     off_set_time_arr[N_conc];
    real<lower = N_data[1]* max(dif_time)>        time_offset_off_ligand_wash;


    /*cross_validierung...........................................*/
    vector<lower = -1400, upper = 100*N_ion_ch+4000>[2]              y_start_hold[N_conc, N_data[1]];
    vector<lower = -1400,upper = 100*N_ion_ch+4000>[2]               y_equi_before_jump_hold[N_conc];
    vector<lower = -1500, upper = 100*N_ion_ch+4000>[2]                 y_dec_hold[N_conc,N_data[2]];
    vector<lower = -1400, upper = 100*N_ion_ch+4000>[2]               y_equi_after_jump_hold[N_conc];
    //vector<lower = -100 ,upper = 100>[10]                                           y_ExpVariance[10];


    /*Pior information...................................*/
    /*Model declaration..................................*/
    int<lower = 2>                                                  M_states;
    //special to simpliest connected models...............
    int<lower = 4, upper =  (M_states)*2>                         N_free_para;
    vector<lower = 0, upper = 140>[N_free_para]                      ligand_conc[N_conc+1];
    vector<lower = 0, upper = 1> [N_free_para]                      ligand_conc_decay[N_conc];

}

transformed data{
    real numeric_precision = 10^-7;
    int  Upper_space_lim = 10000;           #2000
    real lower_lim = 4;

    //print("off_set_time_arr = ", off_set_time_arr);


   int resultFlattSize = max(N_data[1],N_data[2])*2+6+3*N_free_para;
   real trans_real[4 * N_conc, resultFlattSize];
   int trans_int[4 * N_conc, 6];
      if(N_ion_ch >=1000){
      Upper_space_lim = 6000;
   }
   if(N_ion_ch >=1000){
     lower_lim = 10;
   }

   if(N_ion_ch >=5000){
      Upper_space_lim = 1000;
   }
   if(N_ion_ch >=5000){
     lower_lim = 50;
   }

   if(N_ion_ch >=15000){
      Upper_space_lim = 800;
   }
   if(N_ion_ch >=15000){
     lower_lim = 100;
   }

    for(id in 1 : N_conc)
    {
     trans_real[id,:]= flattenData(y_start[id],
                        y_equi_before_jump[id],
                        dif_time[id],
                        off_set_time_arr[id],
                        ligand_conc[1],
                        ligand_conc[1+id],
                        ligand_conc[1+id],
                        numeric_precision,
                        N_data[1],N_free_para,resultFlattSize,
                        time_offset_off_ligand_wash);
    }
    for(id in 1 : N_conc)
    {
     trans_real[id+N_conc,:]= flattenData(y_dec[id],
                                          y_equi_after_jump[id],
                                          dif_time_dec[id],
                                          time_off_set_dec[id],
                                          // since I start no from equilibrium
                                          //and calculate the almost equilibrium
                                          //there is no id +1 in ligand_conc
                                          ligand_conc[1],
                                          ligand_conc[id+1],
                                          ligand_conc_decay[id],
                                          numeric_precision
                                          ,N_data[2],N_free_para,resultFlattSize,
                                          time_offset_off_ligand_wash);
    }


    //hold out data for crossvalidation
    for(id in 1 : N_conc)
    {
     trans_real[id+2*N_conc,:]= flattenData(y_start_hold[id],
                        y_equi_before_jump_hold[id],
                        dif_time[id],
                        off_set_time_arr[id],
                        ligand_conc[1],
                        ligand_conc[1+id],
                        ligand_conc[1+id],
                        numeric_precision,
                        N_data[1],N_free_para,resultFlattSize,
                        time_offset_off_ligand_wash);
    }
    for(id in 1 : N_conc)
    {
    trans_real[id+3*N_conc,:]= flattenData(y_dec_hold[id],
                                          y_equi_after_jump_hold[id],
                                          dif_time_dec[id],
                                          time_off_set_dec[id],
                                          // since I start no from equilibrium
                                          //and calculate the almost equilibrium
                                          //there is no id +1 in ligand_conc
                                          ligand_conc[1],
                                          ligand_conc[id+1],
                                          ligand_conc_decay[id],
                                          numeric_precision
                                          ,N_data[2],N_free_para,resultFlattSize,
                                          time_offset_off_ligand_wash);
    }








    for(id in 1 : 4*N_conc)
    {
      trans_int[id,1] = N_free_para;

      if (id <= N_conc)
      {
        trans_int[id,2] = N_data[1];
        trans_int[id,4] = id;
      }
      else
      {
        if(id <= 2*N_conc){
            trans_int[id,2] = N_data[2];
            trans_int[id,4] = id - N_conc;
        }
        //cross vaildation data case
        else{
            if(id <= 3*N_conc){
                trans_int[id,2] = N_data[1];
                trans_int[id,4] = id - 2*N_conc;
            }
            else{
                trans_int[id,2] = N_data[2];
                trans_int[id,4] = id - 3*N_conc;
            }
        }
      }

      trans_int[id,3] = M_states;

      trans_int[id,5] = N_conc;
      //CPU id um zubestimmen um welchen Datensatz es sich jetzte handelt
      // Decay or Not
      if(id <= 2*N_conc){
        trans_int[id,6] = id;
       }
      else{
        trans_int[id,6] = id - 2*N_conc;
      }
    }
}


parameters {// N_free_param+ N_conc/2 +4
            real<lower = lower_lim, upper = Upper_space_lim>                       rates[N_free_para/2];
            real<lower = 0.0, upper = 1>                                               ratio[N_free_para/2];
            real<lower = N_ion_ch-N_ion_ch*0.2, upper = N_ion_ch+N_ion_ch*0.2>         N_ion_trace[N_conc/2];
            real<lower = 0.1, upper = 2>                                               i_single_channel;    //single channel current
            real<lower = 0.00001, upper = 1>                                           var_exp;        //sigma_squaered
            real<lower = 0.0, upper = 1>                                               OpenVar;       //var open channel noise
            real<lower = 0.00001,upper =1>                                             var_fluoresc; //6000 before // 30000>
            real<lower = 0.2, upper = 20>                                            lambda_fluoresc;


}
transformed parameters {

    /*2 different data types and covaricance of these makes a 2*3 container for each of the N_data timesteps*/
    //real               param_likelihood_start[N_conc,  2,3, N_data[1]+1];
    //real               param_likelihood_decay[N_conc, 2, 3, N_data[2]+1];
    vector<upper = 0> [2*N_conc] SummandsLogLikTraces;

    //cross validation
    vector<upper = 0> [2*N_conc] SummandsLogLikTraces_hold;
    //real               param_likelihood_start_hold[N_conc,  2,3, N_data[1]+1];
    //real               param_likelihood_decay_hold[N_conc, 2, 3, N_data[2]+1];

    {int current;
    vector[0] theta[N_conc*4];  // job specific, ignore me N_conc * 4 becaus 2 training and 2 times cross validation
    //vector[4*N_conc*2*3*(N_data[1]+1)+ 4 * N_conc] result ;
    //Alternativ for less memory
    vector[4*N_conc] result;

    vector[N_free_para+ N_conc/2 + 5] flattendParameters;

    //The procduct of N_ion_trace with i_single decorelates N_ion_trace by making it the ration between N_trace with i_single

    flattendParameters = flattenParameterProposal(i_single_channel, rates,ratio, N_ion_trace,
                                    var_exp, OpenVar, var_fluoresc, lambda_fluoresc, N_free_para, N_conc);


    result = map_rect( wrapped_calculate_likelyhood_less_memo,
                flattendParameters,
                theta, trans_real, trans_int);


    /*current =1;
    for(id in 1: N_conc)
    {
      for (i in 1: 2)
      {
        for (j in 1: 3)
        {
          for (k in 1: N_data[1]+1)
          {
            param_likelihood_start[id,i,j,k] = result[current];
            current+=1;
          }
        }
      }
     SummandsLogLikTraces[id] = result[current];
     current +=1;
    }

    for(id in 1: N_conc)
    {
      for (i in 1: 2)
      {
        for (j in 1: 3)
        {
          for (k in 1: N_data[2]+1)
          {
            param_likelihood_decay[id,i,j,k] = result[current];
            current+=1;
          }
        }
      }
      SummandsLogLikTraces[id+N_conc] = result[current];
      current +=1;
    }

    // hold out data set for cross validation
    for(id in 1: N_conc)
    {
      for (i in 1: 2)
      {
        for (j in 1: 3)
        {
          for (k in 1: N_data[1]+1)
          {
            param_likelihood_start_hold[id,i,j,k] = result[current];
            current+=1;
          }
        }
      }
     SummandsLogLikTraces_hold[id] = result[current];
     current +=1;
    }

        for(id in 1: N_conc)
    {
      for (i in 1: 2)
      {
        for (j in 1: 3)
        {
          for (k in 1: N_data[2]+1)
          {
            param_likelihood_decay_hold[id,i,j,k] = result[current];
            current+=1;
          }
        }
      }
      SummandsLogLikTraces_hold[id+N_conc] = result[current];
      current +=1;
    }
    */
    SummandsLogLikTraces = result[:2*N_conc];
    SummandsLogLikTraces_hold = result[2*N_conc+1:4*N_conc];
    }



}



model{
        rates[1]    ~ uniform(lower_lim,Upper_space_lim); //// normal(100, 100);
    rates[2]    ~ uniform(lower_lim,Upper_space_lim); //normal(500,500);//
    rates[3]    ~ uniform(lower_lim,Upper_space_lim); //normal(10,10);//
    //rates[4]    ~ normal(0.0,0.1)T[0,Upper_space_lim];//exponential(0.001)T[0,Upper_space_lim];//;//uniform(0.01,Upper_space_lim);// //exponential(0.001);//normal(0.0,1000)T[0,Upper_space_lim];
    //rates[5]    ~ normal(0.0,0.1)T[0,Upper_space_lim];//exponential(0.001)T[0,Upper_space_lim];

    ratio[1]    ~ beta(1.00001, 1.00001);    //1.001
    ratio[2]    ~ beta(1.00001, 1.00001);
    ratio[3]    ~ beta(1.00001, 1.00001);
    //ratio[4]    ~ beta(0.9, 1.1);
    //time reversibilty auxillary
    //ratio[5]    ~ beta(0.9, 1.1);


    //N_ion_trace[1] ~ normal(10000,0.01);
    //N_ion_trace[2] ~ normal(10000,0.01);
    //N_ion_trace[3] ~ normal(10000,0.01);
    //N_ion_trace[4] ~ normal(10000,0.01);
    //N_ion_trace[5] ~ normal(10000,0.01);

    var_exp ~ normal(0.25, 0.0025)T[0.00001,15];
    //for(i in 1 :10)
    //    y_ExpVariance[i]       ~ normal(0,var_exp);
    //}
    //var_fluoresc      ~ normal(0.003,0.0001)T[0,];
    OpenVar             ~ normal(0.0025,0.000025)T[0.0,2.5];
    //lambda_fluoresc   ~ normal(0.75, 0.00000075)T[0.00001,10];
    i_single_channel    ~ normal(1,0.01)T[0.5,1.5];

    target += sum(SummandsLogLikTraces[:2*N_conc]);

}


generated quantities{/* Muss überarbeitedt werden signal einbauchen usw...
    vector[N_data[1]+N_data[2]] log_lik_t[N_conc];
    vector[N_data[1]+N_data[2]] log_lik_h[N_conc];
    for(n_conc in 1 : N_conc){
        for(id in 1 : N_data[1]){
            log_lik_t[n_conc,id] =  binomial_lpmf(y_start[n_conc, id]   | N_ion_ch, occupat[id,n_conc,M_states]);
            log_lik_h[n_conc,id] =  binomial_lpmf(y_start_hold[n_conc, id] | N_ion_ch, occupat[id,n_conc,M_states]);


                                                                            //normal_lpdf( | occupat[id,n_conc,M_states],
                                                                            // sqrt((occupat[id,n_conc,M_states]*(1-occupat[id,n_conc,M_states]))/mu));
        }


        for(id in (N_data[1]+1) : (N_data[1]+N_data[2])){

            log_lik_t[n_conc,id] =  binomial_lpmf(y_dec[N_conc, id - N_data[1]]     | N_ion_ch, clamp_sig_decay[id- N_data[1],N_conc]);
            log_lik_h[n_conc,id] =  binomial_lpmf(y_dec_hold[N_conc, id - N_data[1]]| N_ion_ch, clamp_sig_decay[id - N_data[1],N_conc]);

                                                                            //log_lik_t_decay[n_conc,N_data[1]+id] =  normal_lpdf(y_dec[n_conc,id]| occupat_decay[id,N_conc,M_states],
                                                                            //sqrt((occupat_decay[id,n_conc,M_states]*(1-occupat_decay[id,n_conc,M_states]))/mu));           //Likelihood
        }

    }*/
}